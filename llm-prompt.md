Du bist mein "Cloud-Run Service Generator" für data-tales.dev. INPUT (von mir): A) Ein bereits vorhandenes Datenset aus meinem Crawler: - JSON: out_pawpatrol_characters/characters.json - Bilder: out_pawpatrol_characters/images/* Struktur in characters.json (vereinfacht): { "meta": {...}, "characters": [ { "id": "chase", "name": "Chase", "profile_flat": { "Species": "...", "Breed": "...", ... }, "profile": [ { "label": "...", "value": "..." }, ... ], "profile_groups": [ { "group": "...", "fields": [ ... ] } ], "image": { "local_path": "images/chase.jpg", "info": {...} }, "source": { "page_url": "...", "attribution": "..." }, ... } ] } B) Eine Liste vorhandener Services (Name + URL), plus Landing-URL. -> Bisher nur plz.data-tales.dev und jetzt diesen service C) Styling-Referenz: Meine Landing Page nutzt CSS-Variablen und Komponenten (siehe Anhang). Nutzte diese und verwerfe variablen die du nicht benutzt hast. ZIEL: Baue aus dem Datenset ein vollständiges, lauffähiges Mini-Webprojekt, das auf Google Cloud Run deploybar ist (Source Deploy, ohne Dockerfile), mit: - Flask Backend + Gunicorn Start (Cloud Run kompatibel, PORT via env) - einer HTML Oberfläche für den User (Charakter-Galerie) - einem einheitlichen Header (sticky, blur, gleiche Variablen/Buttons wie Landing Page) - Theme Toggle (dark/light) mit localStorage, identisch zum Landing Verhalten - Navigation: Links zur Landing Page + Links zu den anderen Services - sauberer Fehlerbehandlung im UI (keine Stacktraces), robuste Dateipfade - /api Endpunkte als JSON (für spätere Integration) FUNKTIONALE UI-ANFORDERUNGEN (wichtig): 1) Die Website zeigt ALLE Charaktere an, die ein nicht-leeres profile_flat besitzen. 2) Pro Charakter wird eine Card gerendert: - Oben: Name - Darunter: Bild 3) Bilder müssen in einem einheitlichen visuellen Format erscheinen, auch wenn Originale unterschiedliche Größen haben: - Verwende CSS-Technik wie aspect-ratio + object-fit: cover (oder eine äquivalente Lösung), damit alle Thumbnails gleich groß wirken (z.B. 1:1 oder 4:3). 4) Klick-Verhalten (Accordion pro Karte, exklusiv offen): - Klick auf eine Card klappt sie auf (Details werden sichtbar). - Wenn eine andere Card geöffnet wird, schließt die vorherige automatisch. - Klick auf eine bereits geöffnete Card schließt sie wieder. 5) Im aufgeklappten Bereich werden die profile_flat Einträge als Key/Value-Liste angezeigt (z.B. 2-spaltig: Label links, Wert rechts; responsiv auf mobil untereinander). 6) Lizenz/Quelle: Da Weitergabe CC-BY-SA erfordert, zeige in der aufgeklappten Card sichtbar eine Quellenzeile: - Nutze character.source.attribution (oder zumindest character.source.page_url + Hinweis auf Lizenz), sodass Attribution im UI vorhanden ist. API-ANFORDERUNGEN: - GET /api/characters -> { ok: true, count: N, characters: [...] } -> liefert nur Charaktere mit non-empty profile_flat (wie im UI) - GET /api/characters/<id> -> { ok: true, character: {...} } oder { ok: false, error: "not found" } - GET /media/<path> oder äquivalent: -> liefert lokale Bilder aus out_pawpatrol_characters/images/ sicher aus (Path-Traversal verhindern) AUSGABEFORMAT (sehr wichtig): Gib AUSSCHLIESSLICH die folgenden Dateien aus, jeweils in einem eigenen Codeblock mit Dateiname als Überschrift: 1) requirements.txt 2) main.py 3) README.md Keine weiteren Erklärtexte außerhalb der Dateien. ARCHITEKTUR-VORGABEN: - Datei heißt main.py und exportiert app (Flask instance), damit Cloud Run standardmäßig gunicorn -b :$PORT main:app nutzen kann. - Keine externen Templates-Dateien; nutze render_template_string, damit es bei 3 Dateien bleibt. - Kein Docker Compose, kein Dockerfile. - Projekt liest das Datenset aus dem Repo-Dateisystem: - Default: out_pawpatrol_characters/characters.json - Default: out_pawpatrol_characters/ als Basis für image.local_path - Optional konfigurierbar per ENV: - DATA_JSON_PATH (Pfad zur JSON) - DATA_BASE_DIR (Basis für relative Pfade wie image.local_path) - Beim Start: JSON einmalig laden, validieren (Schema-light), und in-memory cachen (z.B. lru_cache oder global). - Strikte Robustheit: - Wenn JSON fehlt oder ungültig: UI zeigt klare Fehlermeldung (Card) und API liefert {ok:false,...}. - Keine Stacktraces im Browser. - Input-Validierung: - id in /api/characters/<id> nur [a-z0-9-]{1,80} zulassen. - media Route muss Path-Traversal verhindern (nur erlaubte Unterpfade unterhalb DATA_BASE_DIR). - Caching: - Für JSON: in-memory Cache. - Für Bilder: sinnvolle Cache-Header (z.B. Cache-Control: public, max-age=...) sofern möglich. LANDING STYLE CSS (muss verwendet werden): - Im UI: Nutze exakt die CSS Variablen aus meiner Landing Page als :root und [data-theme="light"]. - Header-Komponenten semantisch an Landing Page angelehnt: - .site-header, .container, .header-inner, .brand, .brand-mark, .nav, .header-actions, .btn, .btn-primary, .btn-ghost - Du darfst zusätzlich minimal ergänzen (z.B. .char-grid, .char-card, .char-thumb, .char-details), aber NICHT den Look ändern. - Entferne Variablen, die du nicht nutzt. HEADER/LINKS: - Brand klickt auf LANDING_URL - Nav enthält: "Landing", "Cookbook", plus 3–8 Service Links aus SERVICES-LISTE - Rechtes Ende: Theme Toggle Button (☾/☀) + optional ein Primary Button, der zur Landing-Kontaktsektion verlinkt - Wenn Services-Liste > 6: gib nur die ersten 6 in den Header und ergänze einen "Mehr…" Link, der zur Landing Page #projects führt. - Schreibe keine generischen Platzhalter-Links. Nutze exakt die oben angegebenen URLs. Wenn Einträge Platzhalter sind (z.B. enthalten "<...>"), ignoriere sie. THEME TOGGLE (identisch zur Landing): - setzt data-theme="light" auf document.documentElement (oder entfernt es) - speichert theme in localStorage - Icon wechselt ☾/☀ ERWARTETES VERHALTEN IM BROWSER: - Startseite zeigt direkt die Charakter-Galerie (ohne Such-„Submit“ Pflicht). - Cards zeigen Name + Bild, einheitlich zugeschnitten. - Klick klappt Details (profile_flat + Quelle) exklusiv auf/zu. - Fehlerzustände (fehlende Daten/Images) werden sauber und nicht technisch angezeigt. README-VORGABEN: - Kurzer Zweck (1–2 Sätze) - Lokales Starten: - python -m venv .venv - pip install - python main.py - URL nennen - Cloud Run Deploy (Source): - gcloud run deploy <service-name> --source . --region europe-west1 --allow-unauthenticated - Hinweis auf env vars (falls genutzt): DATA_JSON_PATH, DATA_BASE_DIR, optional USER_AGENT - Optional: Domain mapping Hinweis "Subdomain -> Cloud Run" INPUT-DATEN: LANDING_URL = "https://data-tales.dev/" COOKBOOK_URL = "https://data-tales.dev/cookbook/" SERVICES (Name -> URL): - "PLZ → Koordinaten" -> "https://plz.data-tales.dev/" - "<Service 2 Name>" -> "<https://...>" - "<Service 3 Name>" -> "<https://...>" SERVICE_META: - service_name_slug: "paw" - page_title: "PAW Patrol – Charaktere" - page_h1: "PAW Patrol Charaktere" - page_subtitle: "Galerie mit Steckbriefen aus dem lokalen Datenset (inkl. Quellenhinweis)." WICHTIG: - Liefere lauffähigen Code ohne TODOs. - Keine externen Template-Dateien; alles in main.py via render_template_string. - Keine zusätzlichen erklärenden Texte außerhalb der drei Dateien.